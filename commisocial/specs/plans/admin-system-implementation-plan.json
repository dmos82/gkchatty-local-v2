{
  "status": "success",
  "phase": "planning",
  "metadata": {
    "project": "CommiSocial Admin User Management System",
    "phase": "Phase 3 - BMAD Planning",
    "date": "2025-10-27",
    "planner": "BMAD Planner Agent",
    "task_count": 18,
    "estimated_total_hours": 42,
    "critical_path": [
      "TASK-001",
      "TASK-002",
      "TASK-003",
      "TASK-004",
      "TASK-005",
      "TASK-006",
      "TASK-009",
      "TASK-015"
    ]
  },
  "outputs": {
    "tasks": [
      {
        "id": "TASK-001",
        "title": "Install Required Dependencies",
        "priority": "critical",
        "dependencies": [],
        "estimated_hours": 0.5,
        "type": "infrastructure",
        "description": "Install all required npm packages for admin system: Zod for validation, React Hook Form for form management, date-fns for date formatting, and csv-stringify for audit log export.",
        "acceptance_criteria": [
          "zod ^3.22.4 installed",
          "react-hook-form ^7.49.2 installed",
          "@hookform/resolvers ^3.3.3 installed",
          "date-fns ^3.0.6 installed",
          "csv-stringify ^6.4.6 installed",
          "package.json updated with new dependencies",
          "pnpm install completes without errors",
          "TypeScript recognizes new imports"
        ],
        "files": {
          "create": [],
          "modify": ["package.json", "pnpm-lock.yaml"]
        },
        "implementation_notes": [
          "Use pnpm as package manager (existing project standard)",
          "Add all dependencies in single command: pnpm add zod react-hook-form @hookform/resolvers date-fns csv-stringify",
          "Verify no version conflicts with existing dependencies",
          "No code changes needed - just dependency installation"
        ],
        "code_snippets": [
          {
            "language": "bash",
            "code": "pnpm add zod react-hook-form @hookform/resolvers date-fns csv-stringify"
          }
        ]
      },
      {
        "id": "TASK-002",
        "title": "Create Database Migration: Add Admin Columns to Profiles",
        "priority": "critical",
        "dependencies": ["TASK-001"],
        "estimated_hours": 1.5,
        "type": "database",
        "description": "Alter profiles table to add admin-specific columns: role (user/admin/super_admin), deleted_at (soft delete), mfa_enabled, mfa_enforced_at, and last_login. Add indexes for performance.",
        "acceptance_criteria": [
          "Migration file created: 20251028_add_admin_columns.sql",
          "role column added with CHECK constraint",
          "deleted_at column added (nullable)",
          "mfa_enabled column added (default false)",
          "mfa_enforced_at column added (nullable)",
          "last_login column added (nullable)",
          "Indexes created: idx_profiles_role, idx_profiles_deleted_at, idx_profiles_created_at",
          "Full-text search index created for username/email search",
          "Migration applies successfully via Supabase CLI",
          "No data loss (existing users remain user role)"
        ],
        "files": {
          "create": ["supabase/migrations/20251028_add_admin_columns.sql"],
          "modify": []
        },
        "implementation_notes": [
          "Follow existing migration naming pattern: YYYYMMDD_description.sql",
          "Use IF NOT EXISTS for idempotency (safe to re-run)",
          "Default role to 'user' for existing records",
          "Add GIN index for full-text search (ts_vector)",
          "Partial index on deleted_at (WHERE deleted_at IS NULL) for performance",
          "Test migration on local Supabase before deploying"
        ],
        "code_snippets": [
          {
            "language": "sql",
            "code": "-- Add role column with constraint\nALTER TABLE profiles ADD COLUMN IF NOT EXISTS role TEXT NOT NULL DEFAULT 'user'\n  CHECK (role IN ('user', 'admin', 'super_admin'));\n\n-- Add soft delete column\nALTER TABLE profiles ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;\n\n-- Add MFA columns\nALTER TABLE profiles ADD COLUMN IF NOT EXISTS mfa_enabled BOOLEAN NOT NULL DEFAULT false;\nALTER TABLE profiles ADD COLUMN IF NOT EXISTS mfa_enforced_at TIMESTAMPTZ;\n\n-- Add last login tracking\nALTER TABLE profiles ADD COLUMN IF NOT EXISTS last_login TIMESTAMPTZ;\n\n-- Indexes for admin queries\nCREATE INDEX IF NOT EXISTS idx_profiles_role ON profiles(role);\nCREATE INDEX IF NOT EXISTS idx_profiles_deleted_at ON profiles(deleted_at) WHERE deleted_at IS NULL;\nCREATE INDEX IF NOT EXISTS idx_profiles_created_at ON profiles(created_at DESC);\nCREATE INDEX IF NOT EXISTS idx_profiles_username ON profiles(username);\nCREATE INDEX IF NOT EXISTS idx_profiles_email ON profiles(email);\n\n-- Full-text search index\nCREATE INDEX IF NOT EXISTS idx_profiles_search ON profiles\n  USING gin(to_tsvector('english', username || ' ' || COALESCE(display_name, '') || ' ' || email));"
          }
        ]
      },
      {
        "id": "TASK-003",
        "title": "Create Database Migration: Audit Logs Table",
        "priority": "critical",
        "dependencies": ["TASK-002"],
        "estimated_hours": 1.5,
        "type": "database",
        "description": "Create audit_logs table for immutable logging of all admin actions. Include columns for admin_id, action type, target_user_id, old_value, new_value, IP address, and user agent. Add indexes for fast filtering.",
        "acceptance_criteria": [
          "Migration file created: 20251028_create_audit_logs_table.sql",
          "audit_logs table created with all required columns",
          "action column has CHECK constraint for valid action types",
          "old_value and new_value are JSONB (flexible schema)",
          "Indexes created: timestamp DESC, admin_id, action, target_user_id",
          "Composite index created: (admin_id, timestamp DESC)",
          "Table comments added for documentation",
          "Migration applies successfully",
          "No foreign key cascade deletes (preserve audit logs)"
        ],
        "files": {
          "create": ["supabase/migrations/20251028_create_audit_logs_table.sql"],
          "modify": []
        },
        "implementation_notes": [
          "Use JSONB for old_value/new_value (flexible, can store any structure)",
          "Foreign keys use ON DELETE SET NULL (preserve logs even if user deleted)",
          "Add CHECK constraint for action types (prevents typos)",
          "Timestamp index DESC for reverse chronological queries",
          "No UPDATE or DELETE policies (immutable logs)",
          "Add table comment explaining retention policy (2 years)"
        ],
        "code_snippets": [
          {
            "language": "sql",
            "code": "CREATE TABLE IF NOT EXISTS audit_logs (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  admin_id UUID REFERENCES profiles(id) ON DELETE SET NULL,\n  action TEXT NOT NULL CHECK (action IN (\n    'user_created',\n    'user_updated',\n    'password_reset',\n    'role_changed',\n    'user_deleted',\n    'user_restored',\n    'permanent_delete',\n    'mfa_enabled',\n    'mfa_disabled'\n  )),\n  target_user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,\n  old_value JSONB,\n  new_value JSONB,\n  ip_address INET,\n  user_agent TEXT,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- Indexes for fast filtering\nCREATE INDEX idx_audit_logs_timestamp ON audit_logs(timestamp DESC);\nCREATE INDEX idx_audit_logs_admin_id ON audit_logs(admin_id);\nCREATE INDEX idx_audit_logs_action ON audit_logs(action);\nCREATE INDEX idx_audit_logs_target_user_id ON audit_logs(target_user_id);\nCREATE INDEX idx_audit_logs_admin_timestamp ON audit_logs(admin_id, timestamp DESC);\n\n-- Documentation\nCOMMENT ON TABLE audit_logs IS 'Immutable audit log of all admin actions. Retained for 2 years for compliance.';\nCOMMENT ON COLUMN audit_logs.old_value IS 'Previous state before change (JSONB for flexibility)';\nCOMMENT ON COLUMN audit_logs.new_value IS 'New state after change (JSONB for flexibility)';"
          }
        ]
      },
      {
        "id": "TASK-004",
        "title": "Create Database Migration: MFA Recovery Codes Table",
        "priority": "high",
        "dependencies": ["TASK-002"],
        "estimated_hours": 1,
        "type": "database",
        "description": "Create mfa_recovery_codes table to store hashed recovery codes for MFA. Each user gets 10 single-use codes. Add trigger to enforce 10-code limit.",
        "acceptance_criteria": [
          "Migration file created: 20251028_create_mfa_recovery_codes_table.sql",
          "mfa_recovery_codes table created",
          "code_hash column stores bcrypt hashes (never plain text)",
          "used_at column tracks when code was used",
          "Foreign key ON DELETE CASCADE (delete codes when user deleted)",
          "Index created on user_id",
          "Trigger enforces max 10 unused codes per user",
          "Migration applies successfully"
        ],
        "files": {
          "create": ["supabase/migrations/20251028_create_mfa_recovery_codes_table.sql"],
          "modify": []
        },
        "implementation_notes": [
          "Store bcrypt hash, never plain text recovery codes",
          "Cascade delete when user deleted (GDPR compliance)",
          "Trigger prevents more than 10 unused codes per user",
          "used_at nullable (NULL = unused, timestamp = used)",
          "Index on user_id for fast lookup during MFA challenge"
        ],
        "code_snippets": [
          {
            "language": "sql",
            "code": "CREATE TABLE IF NOT EXISTS mfa_recovery_codes (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,\n  code_hash TEXT NOT NULL,\n  used_at TIMESTAMPTZ,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_mfa_recovery_codes_user_id ON mfa_recovery_codes(user_id);\n\n-- Constraint: Each user has exactly 10 recovery codes\nCREATE OR REPLACE FUNCTION check_recovery_code_limit()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF (SELECT COUNT(*) FROM mfa_recovery_codes WHERE user_id = NEW.user_id AND used_at IS NULL) >= 10 THEN\n    RAISE EXCEPTION 'User already has 10 unused recovery codes';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER enforce_recovery_code_limit\nBEFORE INSERT ON mfa_recovery_codes\nFOR EACH ROW\nEXECUTE FUNCTION check_recovery_code_limit();"
          }
        ]
      },
      {
        "id": "TASK-005",
        "title": "Create Database Migration: RLS Policies for Admin Access",
        "priority": "critical",
        "dependencies": ["TASK-003", "TASK-004"],
        "estimated_hours": 2,
        "type": "database",
        "description": "Create Row-Level Security policies for admin access to profiles, audit_logs, and mfa_recovery_codes. Enforce role-based access and prevent admins from editing own critical fields.",
        "acceptance_criteria": [
          "Migration file created: 20251028_add_admin_rls_policies.sql",
          "RLS policies added for profiles: admins can SELECT all, UPDATE others (not self)",
          "RLS policies added for audit_logs: admins can SELECT all, INSERT own logs, NO UPDATE/DELETE",
          "RLS policies added for mfa_recovery_codes: users can manage own codes",
          "Super admin role check policy created for role changes",
          "Trigger added: prevent demotion of last super_admin",
          "Policies tested: admin can view/edit users, cannot edit self, cannot delete audit logs",
          "Migration applies successfully"
        ],
        "files": {
          "create": ["supabase/migrations/20251028_add_admin_rls_policies.sql"],
          "modify": []
        },
        "implementation_notes": [
          "Use subquery EXISTS pattern for role checks (performance)",
          "Admins cannot UPDATE own record via admin panel (prevents privilege escalation)",
          "Super admin check: NEW.role != OLD.role requires super_admin role",
          "Audit logs: SELECT for admins, INSERT for admins, NO UPDATE/DELETE (immutable)",
          "Add trigger to prevent demotion of last super_admin",
          "Test policies in isolation before deploying"
        ],
        "code_snippets": [
          {
            "language": "sql",
            "code": "-- Enable RLS on all tables\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;\nALTER TABLE mfa_recovery_codes ENABLE ROW LEVEL SECURITY;\n\n-- Profiles: Admins can view all users\nCREATE POLICY \"Admins can view all users\" ON profiles\n  FOR SELECT\n  USING (\n    EXISTS (\n      SELECT 1 FROM profiles\n      WHERE id = auth.uid()\n      AND role IN ('admin', 'super_admin')\n    )\n  );\n\n-- Profiles: Admins can update users (except own record)\nCREATE POLICY \"Admins can update users\" ON profiles\n  FOR UPDATE\n  USING (\n    EXISTS (\n      SELECT 1 FROM profiles\n      WHERE id = auth.uid()\n      AND role IN ('admin', 'super_admin')\n    )\n    AND id != auth.uid()\n  )\n  WITH CHECK (\n    EXISTS (\n      SELECT 1 FROM profiles\n      WHERE id = auth.uid()\n      AND role IN ('admin', 'super_admin')\n    )\n    AND id != auth.uid()\n  );\n\n-- Audit Logs: Admins can view all logs\nCREATE POLICY \"Admins can view audit logs\" ON audit_logs\n  FOR SELECT\n  USING (\n    EXISTS (\n      SELECT 1 FROM profiles\n      WHERE id = auth.uid()\n      AND role IN ('admin', 'super_admin')\n    )\n  );\n\n-- Audit Logs: Admins can insert logs (application-level)\nCREATE POLICY \"Admins can insert audit logs\" ON audit_logs\n  FOR INSERT\n  WITH CHECK (\n    admin_id = auth.uid()\n    AND EXISTS (\n      SELECT 1 FROM profiles\n      WHERE id = auth.uid()\n      AND role IN ('admin', 'super_admin')\n    )\n  );\n\n-- NO UPDATE OR DELETE POLICIES FOR AUDIT LOGS (immutable)\n\n-- Trigger: Prevent demotion of last super_admin\nCREATE OR REPLACE FUNCTION check_last_super_admin()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.role = 'super_admin' AND NEW.role != 'super_admin' THEN\n    IF (SELECT COUNT(*) FROM profiles WHERE role = 'super_admin' AND id != NEW.id) = 0 THEN\n      RAISE EXCEPTION 'Cannot demote the last super_admin';\n    END IF;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER ensure_super_admin_exists\nBEFORE UPDATE ON profiles\nFOR EACH ROW\nEXECUTE FUNCTION check_last_super_admin();"
          }
        ]
      },
      {
        "id": "TASK-006",
        "title": "Create Database Migration: Audit Logging Triggers",
        "priority": "critical",
        "dependencies": ["TASK-005"],
        "estimated_hours": 2,
        "type": "database",
        "description": "Create PostgreSQL triggers to automatically log admin actions to audit_logs table. Triggers for user updates, role changes, soft deletes, and MFA status changes.",
        "acceptance_criteria": [
          "Migration file created: 20251028_add_audit_triggers.sql",
          "Trigger created: log_user_update (username, email, display_name changes)",
          "Trigger created: log_role_change (role column changes)",
          "Trigger created: log_user_deletion (deleted_at changes)",
          "Trigger created: log_mfa_change (mfa_enabled changes)",
          "Each trigger captures old_value and new_value as JSONB",
          "Triggers only fire for admin-performed actions (auth.uid() != target user)",
          "IP address and user agent captured (if available)",
          "Triggers tested: update user → audit log created",
          "Migration applies successfully"
        ],
        "files": {
          "create": ["supabase/migrations/20251028_add_audit_triggers.sql"],
          "modify": []
        },
        "implementation_notes": [
          "Use SECURITY DEFINER for trigger functions (bypass RLS)",
          "Check auth.uid() to identify admin performing action",
          "Only log changes made by admins (not self-updates)",
          "Use WHEN clause to fire only on specific column changes",
          "Capture IP via inet_client_addr() (Supabase provides this)",
          "Use jsonb_build_object() for flexible old/new value storage",
          "Test each trigger individually before deploying"
        ],
        "code_snippets": [
          {
            "language": "sql",
            "code": "-- Trigger 1: Log user updates\nCREATE OR REPLACE FUNCTION log_user_update()\nRETURNS TRIGGER AS $$\nDECLARE\n  v_admin_id UUID;\nBEGIN\n  v_admin_id := auth.uid();\n\n  -- Only log if changes were made by an admin\n  IF v_admin_id IS NOT NULL AND v_admin_id != NEW.id THEN\n    INSERT INTO audit_logs (\n      admin_id,\n      action,\n      target_user_id,\n      old_value,\n      new_value,\n      ip_address\n    ) VALUES (\n      v_admin_id,\n      'user_updated',\n      NEW.id,\n      jsonb_build_object(\n        'username', OLD.username,\n        'email', OLD.email,\n        'display_name', OLD.display_name\n      ),\n      jsonb_build_object(\n        'username', NEW.username,\n        'email', NEW.email,\n        'display_name', NEW.display_name\n      ),\n      inet_client_addr()\n    );\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER audit_user_updates\nAFTER UPDATE ON profiles\nFOR EACH ROW\nWHEN (\n  OLD.username IS DISTINCT FROM NEW.username\n  OR OLD.email IS DISTINCT FROM NEW.email\n  OR OLD.display_name IS DISTINCT FROM NEW.display_name\n)\nEXECUTE FUNCTION log_user_update();\n\n-- Trigger 2: Log role changes\nCREATE OR REPLACE FUNCTION log_role_change()\nRETURNS TRIGGER AS $$\nDECLARE\n  v_admin_id UUID;\nBEGIN\n  v_admin_id := auth.uid();\n\n  IF v_admin_id IS NOT NULL AND OLD.role IS DISTINCT FROM NEW.role THEN\n    INSERT INTO audit_logs (\n      admin_id,\n      action,\n      target_user_id,\n      old_value,\n      new_value,\n      ip_address\n    ) VALUES (\n      v_admin_id,\n      'role_changed',\n      NEW.id,\n      jsonb_build_object('role', OLD.role),\n      jsonb_build_object('role', NEW.role),\n      inet_client_addr()\n    );\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER audit_role_changes\nAFTER UPDATE ON profiles\nFOR EACH ROW\nWHEN (OLD.role IS DISTINCT FROM NEW.role)\nEXECUTE FUNCTION log_role_change();\n\n-- Trigger 3: Log soft deletes\nCREATE OR REPLACE FUNCTION log_user_deletion()\nRETURNS TRIGGER AS $$\nDECLARE\n  v_admin_id UUID;\nBEGIN\n  v_admin_id := auth.uid();\n\n  IF v_admin_id IS NOT NULL AND OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n    INSERT INTO audit_logs (\n      admin_id,\n      action,\n      target_user_id,\n      old_value,\n      new_value,\n      ip_address\n    ) VALUES (\n      v_admin_id,\n      'user_deleted',\n      NEW.id,\n      jsonb_build_object('active', true),\n      jsonb_build_object('deleted_at', NEW.deleted_at),\n      inet_client_addr()\n    );\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER audit_user_deletions\nAFTER UPDATE ON profiles\nFOR EACH ROW\nWHEN (OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL)\nEXECUTE FUNCTION log_user_deletion();\n\n-- Trigger 4: Log MFA status changes\nCREATE OR REPLACE FUNCTION log_mfa_change()\nRETURNS TRIGGER AS $$\nDECLARE\n  v_admin_id UUID;\n  v_action TEXT;\nBEGIN\n  v_admin_id := auth.uid();\n\n  IF OLD.mfa_enabled IS DISTINCT FROM NEW.mfa_enabled THEN\n    v_action := CASE WHEN NEW.mfa_enabled THEN 'mfa_enabled' ELSE 'mfa_disabled' END;\n\n    INSERT INTO audit_logs (\n      admin_id,\n      action,\n      target_user_id,\n      old_value,\n      new_value,\n      ip_address\n    ) VALUES (\n      v_admin_id,\n      v_action,\n      NEW.id,\n      jsonb_build_object('mfa_enabled', OLD.mfa_enabled),\n      jsonb_build_object('mfa_enabled', NEW.mfa_enabled),\n      inet_client_addr()\n    );\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER audit_mfa_changes\nAFTER UPDATE ON profiles\nFOR EACH ROW\nWHEN (OLD.mfa_enabled IS DISTINCT FROM NEW.mfa_enabled)\nEXECUTE FUNCTION log_mfa_change();"
          }
        ]
      },
      {
        "id": "TASK-007",
        "title": "Create Middleware for Route Protection",
        "priority": "critical",
        "dependencies": ["TASK-006"],
        "estimated_hours": 2.5,
        "type": "infrastructure",
        "description": "Create Next.js middleware.ts to protect /admin routes. Checks: 1) User authenticated, 2) User has admin/super_admin role, 3) MFA enabled (7-day grace period), 4) Rate limiting. Capture IP and User-Agent for audit logs.",
        "acceptance_criteria": [
          "middleware.ts created at project root",
          "Checks Supabase session exists (redirect to /login if not)",
          "Checks user role is admin or super_admin (403 if not)",
          "Checks MFA enabled OR within 7-day grace period (redirect to /admin/mfa-setup if expired)",
          "Rate limiting implemented (using Map cache or Upstash Redis)",
          "IP address and User-Agent captured and passed to requests",
          "Matcher configured for /admin/:path*",
          "Middleware runs on every /admin request",
          "Unauthorized users see 403 Forbidden",
          "Tests pass: admin can access, user cannot, deleted user cannot"
        ],
        "files": {
          "create": ["middleware.ts"],
          "modify": []
        },
        "implementation_notes": [
          "Use @supabase/ssr for session management in middleware",
          "Fetch user profile to check role (cached in session JWT if possible)",
          "MFA grace period: 7 days from mfa_enforced_at timestamp",
          "Rate limiting: Simple Map-based cache (MVP), upgrade to Upstash later",
          "Capture request.ip and request.headers['user-agent']",
          "Set custom headers: x-admin-id, x-ip-address for Server Actions",
          "Follow existing SignupForm pattern for error handling"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "import { createServerClient, type CookieOptions } from '@supabase/ssr'\nimport { NextResponse, type NextRequest } from 'next/server'\n\nexport async function middleware(request: NextRequest) {\n  let response = NextResponse.next({\n    request: {\n      headers: request.headers,\n    },\n  })\n\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        get(name: string) {\n          return request.cookies.get(name)?.value\n        },\n        set(name: string, value: string, options: CookieOptions) {\n          request.cookies.set({ name, value, ...options })\n          response = NextResponse.next({\n            request: { headers: request.headers },\n          })\n          response.cookies.set({ name, value, ...options })\n        },\n        remove(name: string, options: CookieOptions) {\n          request.cookies.set({ name, value: '', ...options })\n          response = NextResponse.next({\n            request: { headers: request.headers },\n          })\n          response.cookies.set({ name, value: '', ...options })\n        },\n      },\n    }\n  )\n\n  // 1. Check authentication\n  const { data: { session } } = await supabase.auth.getSession()\n  if (!session) {\n    return NextResponse.redirect(new URL('/login', request.url))\n  }\n\n  // 2. Fetch user profile to check role\n  const { data: profile } = await supabase\n    .from('profiles')\n    .select('role, mfa_enabled, mfa_enforced_at, deleted_at')\n    .eq('id', session.user.id)\n    .single()\n\n  // 3. Check if user is deleted (soft delete)\n  if (profile?.deleted_at) {\n    return new NextResponse('Account deleted', { status: 403 })\n  }\n\n  // 4. Check role (admin or super_admin)\n  if (!profile || !['admin', 'super_admin'].includes(profile.role)) {\n    return new NextResponse('Forbidden - Admin access required', { status: 403 })\n  }\n\n  // 5. Check MFA (7-day grace period)\n  if (!profile.mfa_enabled && profile.mfa_enforced_at) {\n    const gracePeriodEnd = new Date(profile.mfa_enforced_at)\n    gracePeriodEnd.setDate(gracePeriodEnd.getDate() + 7)\n\n    if (new Date() > gracePeriodEnd) {\n      return NextResponse.redirect(new URL('/admin/mfa-setup', request.url))\n    }\n  }\n\n  // 6. Add custom headers for audit logging\n  response.headers.set('x-admin-id', session.user.id)\n  response.headers.set('x-ip-address', request.ip || 'unknown')\n  response.headers.set('x-user-agent', request.headers.get('user-agent') || 'unknown')\n\n  return response\n}\n\nexport const config = {\n  matcher: '/admin/:path*',\n}"
          }
        ]
      },
      {
        "id": "TASK-008",
        "title": "Create Zod Validation Schemas",
        "priority": "high",
        "dependencies": ["TASK-001"],
        "estimated_hours": 1.5,
        "type": "backend",
        "description": "Create Zod schemas for all admin forms: updateUser, resetPassword, changeRole, softDelete, permanentDelete. Generate TypeScript types from schemas.",
        "acceptance_criteria": [
          "File created: lib/admin/validators.ts",
          "Schema created: updateUserSchema (username, email, display_name)",
          "Schema created: resetPasswordSchema (type, password)",
          "Schema created: changeRoleSchema (role: user | admin)",
          "Schema created: softDeleteSchema (reason optional)",
          "Schema created: permanentDeleteSchema (confirm: 'DELETE')",
          "TypeScript types exported: UpdateUserInput, ResetPasswordInput, etc.",
          "Client-side validation works with React Hook Form",
          "Server-side validation works in Server Actions",
          "All regex patterns match requirements (username: 3-20 alphanumeric)"
        ],
        "files": {
          "create": ["lib/admin/validators.ts"],
          "modify": []
        },
        "implementation_notes": [
          "Follow requirements: username 3-20 chars, alphanumeric + underscore",
          "Email validation using z.string().email()",
          "Password complexity: min 8 chars, 1 upper, 1 lower, 1 number, 1 special",
          "Export both schemas and inferred types: export type UpdateUserInput = z.infer<typeof updateUserSchema>",
          "Add custom error messages for better UX",
          "Use z.enum() for role validation (prevents typos)"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "import { z } from 'zod'\n\n// User update schema\nexport const updateUserSchema = z.object({\n  username: z\n    .string()\n    .min(3, 'Username must be at least 3 characters')\n    .max(20, 'Username must be at most 20 characters')\n    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),\n  email: z\n    .string()\n    .email('Invalid email address'),\n  display_name: z\n    .string()\n    .min(1, 'Display name cannot be empty')\n    .max(50, 'Display name must be at most 50 characters')\n    .optional(),\n})\n\nexport type UpdateUserInput = z.infer<typeof updateUserSchema>\n\n// Password reset schema\nconst passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/\n\nexport const resetPasswordSchema = z.object({\n  type: z.enum(['temporary', 'custom']),\n  password: z\n    .string()\n    .regex(\n      passwordRegex,\n      'Password must be at least 8 characters with 1 uppercase, 1 lowercase, 1 number, and 1 special character'\n    )\n    .optional(),\n}).refine(\n  (data) => data.type === 'temporary' || (data.type === 'custom' && data.password),\n  { message: 'Password is required for custom type', path: ['password'] }\n)\n\nexport type ResetPasswordInput = z.infer<typeof resetPasswordSchema>\n\n// Role change schema\nexport const changeRoleSchema = z.object({\n  role: z.enum(['user', 'admin'], {\n    errorMap: () => ({ message: 'Role must be user or admin' }),\n  }),\n})\n\nexport type ChangeRoleInput = z.infer<typeof changeRoleSchema>\n\n// Soft delete schema\nexport const softDeleteSchema = z.object({\n  reason: z.string().max(500).optional(),\n})\n\nexport type SoftDeleteInput = z.infer<typeof softDeleteSchema>\n\n// Permanent delete schema\nexport const permanentDeleteSchema = z.object({\n  confirm: z.literal('DELETE', {\n    errorMap: () => ({ message: 'You must type DELETE to confirm' }),\n  }),\n})\n\nexport type PermanentDeleteInput = z.infer<typeof permanentDeleteSchema>"
          }
        ]
      },
      {
        "id": "TASK-009",
        "title": "Create Server Actions for User Management",
        "priority": "critical",
        "dependencies": ["TASK-007", "TASK-008"],
        "estimated_hours": 4,
        "type": "backend",
        "description": "Create Next.js Server Actions for all admin mutations: updateUser, resetPassword, changeRole, softDeleteUser, permanentDeleteUser. Include authorization guards, validation, and error handling.",
        "acceptance_criteria": [
          "File created: app/admin/actions.ts",
          "Action created: updateUser (validates, updates profile, revalidates)",
          "Action created: resetPassword (generates temp password OR sets custom)",
          "Action created: changeRole (super_admin only, checks last super_admin)",
          "Action created: softDeleteUser (sets deleted_at)",
          "Action created: permanentDeleteUser (super_admin only, 30+ days old, cascade delete)",
          "All actions use 'use server' directive",
          "All actions validate with Zod schemas",
          "All actions check authorization (role, cannot edit self)",
          "All actions return typed responses: { success: boolean, data?, error? }",
          "All actions call revalidatePath after mutation",
          "Audit logs created via database triggers (automatic)"
        ],
        "files": {
          "create": ["app/admin/actions.ts"],
          "modify": []
        },
        "implementation_notes": [
          "Use 'use server' directive at top of file",
          "Get session via createClient() from @supabase/ssr",
          "Check role before every action (admin or super_admin)",
          "Validate input with Zod parse() (throws on invalid)",
          "Fetch old user data before update (for audit log comparison)",
          "Use Supabase Admin API for password reset: supabase.auth.admin.updateUserById()",
          "Cascade delete: Delete user from auth.users (Supabase Admin API)",
          "Return typed responses for better error handling in UI",
          "Follow existing pattern from SignupForm error handling"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "'use server'\n\nimport { createClient } from '@/lib/supabase/server'\nimport { revalidatePath } from 'next/cache'\nimport { updateUserSchema, resetPasswordSchema, changeRoleSchema, softDeleteSchema, permanentDeleteSchema } from '@/lib/admin/validators'\nimport type { UpdateUserInput, ResetPasswordInput, ChangeRoleInput, SoftDeleteInput, PermanentDeleteInput } from '@/lib/admin/validators'\n\ntype ActionResponse<T = void> = \n  | { success: true; data: T }\n  | { success: false; error: string }\n\n// Update user profile\nexport async function updateUser(\n  userId: string,\n  input: UpdateUserInput\n): Promise<ActionResponse<{ username: string; email: string; display_name: string | null }>> {\n  try {\n    const supabase = await createClient()\n\n    // 1. Check authorization\n    const { data: { session } } = await supabase.auth.getSession()\n    if (!session) {\n      return { success: false, error: 'Not authenticated' }\n    }\n\n    const { data: admin } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', session.user.id)\n      .single()\n\n    if (!admin || !['admin', 'super_admin'].includes(admin.role)) {\n      return { success: false, error: 'Unauthorized' }\n    }\n\n    // Cannot edit own profile via admin panel\n    if (session.user.id === userId) {\n      return { success: false, error: 'Cannot edit your own profile' }\n    }\n\n    // 2. Validate input\n    const validated = updateUserSchema.parse(input)\n\n    // 3. Update user\n    const { data, error } = await supabase\n      .from('profiles')\n      .update(validated)\n      .eq('id', userId)\n      .select('username, email, display_name')\n      .single()\n\n    if (error) throw error\n\n    // 4. Revalidate\n    revalidatePath('/admin/users')\n    revalidatePath(`/admin/users/${userId}`)\n\n    return { success: true, data }\n  } catch (error) {\n    console.error('updateUser error:', error)\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }\n  }\n}\n\n// Reset password\nexport async function resetPassword(\n  userId: string,\n  input: ResetPasswordInput\n): Promise<ActionResponse<{ temporary_password?: string; expires_at?: string }>> {\n  try {\n    const supabase = await createClient()\n\n    // 1. Check authorization\n    const { data: { session } } = await supabase.auth.getSession()\n    if (!session) {\n      return { success: false, error: 'Not authenticated' }\n    }\n\n    const { data: admin } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', session.user.id)\n      .single()\n\n    if (!admin || !['admin', 'super_admin'].includes(admin.role)) {\n      return { success: false, error: 'Unauthorized' }\n    }\n\n    // 2. Validate input\n    const validated = resetPasswordSchema.parse(input)\n\n    // 3. Generate or use provided password\n    let password: string\n    if (validated.type === 'temporary') {\n      password = generateTemporaryPassword()\n    } else {\n      password = validated.password!\n    }\n\n    // 4. Update password via Supabase Admin API\n    const { error } = await supabase.auth.admin.updateUserById(userId, {\n      password,\n    })\n\n    if (error) throw error\n\n    // 5. Log action to audit_logs\n    await supabase.from('audit_logs').insert({\n      admin_id: session.user.id,\n      action: 'password_reset',\n      target_user_id: userId,\n      new_value: { type: validated.type },\n    })\n\n    // 6. Send email notification (via Supabase Auth)\n    // Note: Supabase automatically sends email on password reset\n\n    revalidatePath('/admin/users')\n\n    return {\n      success: true,\n      data: validated.type === 'temporary'\n        ? {\n            temporary_password: password,\n            expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n          }\n        : {},\n    }\n  } catch (error) {\n    console.error('resetPassword error:', error)\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }\n  }\n}\n\n// Helper: Generate temporary password\nfunction generateTemporaryPassword(): string {\n  const length = 16\n  const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*'\n  let password = ''\n  for (let i = 0; i < length; i++) {\n    password += charset.charAt(Math.floor(Math.random() * charset.length))\n  }\n  // Ensure complexity requirements\n  if (!/[a-z]/.test(password)) password += 'a'\n  if (!/[A-Z]/.test(password)) password += 'A'\n  if (!/[0-9]/.test(password)) password += '1'\n  if (!/[!@#$%^&*]/.test(password)) password += '!'\n  return password.slice(0, 16)\n}\n\n// Change role (super_admin only)\nexport async function changeRole(\n  userId: string,\n  input: ChangeRoleInput\n): Promise<ActionResponse<{ old_role: string; new_role: string }>> {\n  try {\n    const supabase = await createClient()\n\n    // 1. Check authorization (super_admin only)\n    const { data: { session } } = await supabase.auth.getSession()\n    if (!session) {\n      return { success: false, error: 'Not authenticated' }\n    }\n\n    const { data: admin } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', session.user.id)\n      .single()\n\n    if (!admin || admin.role !== 'super_admin') {\n      return { success: false, error: 'Unauthorized - Super admin only' }\n    }\n\n    // Cannot change own role\n    if (session.user.id === userId) {\n      return { success: false, error: 'Cannot change your own role' }\n    }\n\n    // 2. Validate input\n    const validated = changeRoleSchema.parse(input)\n\n    // 3. Get old role\n    const { data: oldUser } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', userId)\n      .single()\n\n    if (!oldUser) {\n      return { success: false, error: 'User not found' }\n    }\n\n    // 4. Update role\n    const { error } = await supabase\n      .from('profiles')\n      .update({ role: validated.role })\n      .eq('id', userId)\n\n    if (error) throw error\n\n    revalidatePath('/admin/users')\n\n    return {\n      success: true,\n      data: { old_role: oldUser.role, new_role: validated.role },\n    }\n  } catch (error) {\n    console.error('changeRole error:', error)\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }\n  }\n}\n\n// Soft delete user\nexport async function softDeleteUser(\n  userId: string,\n  input: SoftDeleteInput\n): Promise<ActionResponse> {\n  try {\n    const supabase = await createClient()\n\n    // 1. Check authorization\n    const { data: { session } } = await supabase.auth.getSession()\n    if (!session) {\n      return { success: false, error: 'Not authenticated' }\n    }\n\n    const { data: admin } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', session.user.id)\n      .single()\n\n    if (!admin || !['admin', 'super_admin'].includes(admin.role)) {\n      return { success: false, error: 'Unauthorized' }\n    }\n\n    // Cannot delete own account\n    if (session.user.id === userId) {\n      return { success: false, error: 'Cannot delete your own account' }\n    }\n\n    // 2. Validate input\n    const validated = softDeleteSchema.parse(input)\n\n    // 3. Soft delete (set deleted_at)\n    const { error } = await supabase\n      .from('profiles')\n      .update({ deleted_at: new Date().toISOString() })\n      .eq('id', userId)\n\n    if (error) throw error\n\n    revalidatePath('/admin/users')\n\n    return { success: true, data: undefined }\n  } catch (error) {\n    console.error('softDeleteUser error:', error)\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }\n  }\n}\n\n// Permanent delete user (super_admin only, 30+ days old)\nexport async function permanentDeleteUser(\n  userId: string,\n  input: PermanentDeleteInput\n): Promise<ActionResponse> {\n  try {\n    const supabase = await createClient()\n\n    // 1. Check authorization (super_admin only)\n    const { data: { session } } = await supabase.auth.getSession()\n    if (!session) {\n      return { success: false, error: 'Not authenticated' }\n    }\n\n    const { data: admin } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', session.user.id)\n      .single()\n\n    if (!admin || admin.role !== 'super_admin') {\n      return { success: false, error: 'Unauthorized - Super admin only' }\n    }\n\n    // 2. Validate input (must type DELETE)\n    const validated = permanentDeleteSchema.parse(input)\n\n    // 3. Check user is soft-deleted for > 30 days\n    const { data: user } = await supabase\n      .from('profiles')\n      .select('deleted_at')\n      .eq('id', userId)\n      .single()\n\n    if (!user || !user.deleted_at) {\n      return { success: false, error: 'User must be soft-deleted first' }\n    }\n\n    const deletedDate = new Date(user.deleted_at)\n    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)\n\n    if (deletedDate > thirtyDaysAgo) {\n      return { success: false, error: 'User must be soft-deleted for at least 30 days' }\n    }\n\n    // 4. Permanent delete from auth.users (cascade deletes profile)\n    const { error: authError } = await supabase.auth.admin.deleteUser(userId)\n\n    if (authError) throw authError\n\n    // 5. Log permanent deletion\n    await supabase.from('audit_logs').insert({\n      admin_id: session.user.id,\n      action: 'permanent_delete',\n      target_user_id: userId,\n      old_value: { user_id: userId },\n      new_value: null,\n    })\n\n    revalidatePath('/admin/users')\n\n    return { success: true, data: undefined }\n  } catch (error) {\n    console.error('permanentDeleteUser error:', error)\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }\n  }\n}"
          }
        ]
      },
      {
        "id": "TASK-010",
        "title": "Create AdminLayout Component",
        "priority": "high",
        "dependencies": ["TASK-007"],
        "estimated_hours": 2,
        "type": "frontend",
        "description": "Create admin dashboard layout with sidebar navigation, header with user menu, and main content area. Server Component with responsive design.",
        "acceptance_criteria": [
          "File created: app/admin/layout.tsx",
          "Sidebar navigation: Users, Audit Logs, Settings",
          "Header with logo, user info, logout button",
          "Active route highlighting",
          "Responsive design (desktop-first, mobile sidebar collapse)",
          "Dark mode support (follows existing theme)",
          "Uses shadcn/ui components (Card, Button, DropdownMenu)",
          "Server Component (async, fetches user info)",
          "Layout wraps all /admin pages"
        ],
        "files": {
          "create": ["app/admin/layout.tsx", "components/admin/AdminSidebar.tsx", "components/admin/AdminHeader.tsx"],
          "modify": []
        },
        "implementation_notes": [
          "Follow existing layout pattern from app/layout.tsx",
          "Sidebar: Fixed position, 256px width, collapse on mobile",
          "Header: Sticky top, shows current admin username and role",
          "Use Link from next/link for navigation (client-side routing)",
          "Active route: Use usePathname() hook in client component",
          "Logout: Server Action or redirect to /api/auth/signout",
          "Color scheme: Follow globals.css variables"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "// app/admin/layout.tsx\nimport { createClient } from '@/lib/supabase/server'\nimport { redirect } from 'next/navigation'\nimport { AdminSidebar } from '@/components/admin/AdminSidebar'\nimport { AdminHeader } from '@/components/admin/AdminHeader'\n\nexport default async function AdminLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const supabase = await createClient()\n\n  // Get current user\n  const { data: { session } } = await supabase.auth.getSession()\n  if (!session) {\n    redirect('/login')\n  }\n\n  const { data: profile } = await supabase\n    .from('profiles')\n    .select('username, display_name, role, mfa_enabled')\n    .eq('id', session.user.id)\n    .single()\n\n  if (!profile || !['admin', 'super_admin'].includes(profile.role)) {\n    redirect('/')\n  }\n\n  return (\n    <div className=\"flex h-screen bg-background\">\n      <AdminSidebar role={profile.role} />\n      <div className=\"flex flex-1 flex-col overflow-hidden\">\n        <AdminHeader\n          username={profile.username}\n          displayName={profile.display_name}\n          role={profile.role}\n          mfaEnabled={profile.mfa_enabled}\n        />\n        <main className=\"flex-1 overflow-auto p-6\">\n          {children}\n        </main>\n      </div>\n    </div>\n  )\n}"
          },
          {
            "language": "typescript",
            "code": "// components/admin/AdminSidebar.tsx\n'use client'\n\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport { cn } from '@/lib/utils'\nimport { Users, FileText, Settings } from 'lucide-react'\n\ninterface AdminSidebarProps {\n  role: string\n}\n\nexport function AdminSidebar({ role }: AdminSidebarProps) {\n  const pathname = usePathname()\n\n  const navItems = [\n    { href: '/admin', label: 'Dashboard', icon: Settings },\n    { href: '/admin/users', label: 'Users', icon: Users },\n    { href: '/admin/audit-logs', label: 'Audit Logs', icon: FileText },\n  ]\n\n  return (\n    <aside className=\"w-64 border-r bg-card\">\n      <div className=\"flex h-16 items-center border-b px-6\">\n        <h1 className=\"text-xl font-bold\">Admin Panel</h1>\n      </div>\n      <nav className=\"space-y-1 p-4\">\n        {navItems.map((item) => {\n          const Icon = item.icon\n          const isActive = pathname === item.href\n\n          return (\n            <Link\n              key={item.href}\n              href={item.href}\n              className={cn(\n                'flex items-center gap-3 rounded-lg px-3 py-2 text-sm transition-colors',\n                isActive\n                  ? 'bg-primary text-primary-foreground'\n                  : 'hover:bg-accent hover:text-accent-foreground'\n              )}\n            >\n              <Icon className=\"h-5 w-5\" />\n              {item.label}\n            </Link>\n          )\n        })}\n      </nav>\n    </aside>\n  )\n}"
          }
        ]
      },
      {
        "id": "TASK-011",
        "title": "Create User List Page (Server Component)",
        "priority": "critical",
        "dependencies": ["TASK-009", "TASK-010"],
        "estimated_hours": 3,
        "type": "frontend",
        "description": "Create admin user list page with search, filters (role, status), sorting, and pagination. Server Component that fetches data directly from Supabase.",
        "acceptance_criteria": [
          "File created: app/admin/users/page.tsx",
          "Display paginated user list (50 per page)",
          "Search by username, email, or display_name (URL param: ?search=)",
          "Filter by role (URL param: ?role=admin)",
          "Filter by status (active/deleted, URL param: ?status=active)",
          "Sort by username, email, created_at, last_login (URL param: ?sort=username&order=asc)",
          "Pagination controls (prev/next)",
          "Uses shadcn/ui Table component",
          "Click user row → navigate to /admin/users/[userId]",
          "Server Component (async, direct database query)",
          "Loading state while fetching"
        ],
        "files": {
          "create": ["app/admin/users/page.tsx", "components/admin/UserTable.tsx", "components/admin/UserSearch.tsx", "components/admin/UserFilters.tsx"],
          "modify": []
        },
        "implementation_notes": [
          "Follow FeedList pattern: Server Component for data, Client Component for interactions",
          "Use searchParams prop for URL params (Next.js App Router)",
          "Search: Use full-text search index (to_tsvector) for performance",
          "Filters: Use Supabase query builder .eq(), .in() methods",
          "Pagination: LIMIT 50 OFFSET (page - 1) * 50",
          "UserSearch: Client Component with input (debounced)",
          "UserFilters: Client Component with Select dropdowns",
          "Use Link to navigate to user detail page"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "// app/admin/users/page.tsx\nimport { createClient } from '@/lib/supabase/server'\nimport { UserTable } from '@/components/admin/UserTable'\nimport { UserSearch } from '@/components/admin/UserSearch'\nimport { UserFilters } from '@/components/admin/UserFilters'\nimport { Button } from '@/components/ui/button'\nimport Link from 'next/link'\n\ninterface SearchParams {\n  page?: string\n  search?: string\n  role?: string\n  status?: string\n  sort?: string\n  order?: string\n}\n\nexport default async function UsersPage({\n  searchParams,\n}: {\n  searchParams: SearchParams\n}) {\n  const supabase = await createClient()\n\n  // Parse params\n  const page = parseInt(searchParams.page || '1')\n  const search = searchParams.search || ''\n  const role = searchParams.role\n  const status = searchParams.status || 'active'\n  const sort = searchParams.sort || 'created_at'\n  const order = searchParams.order || 'desc'\n  const limit = 50\n  const offset = (page - 1) * limit\n\n  // Build query\n  let query = supabase\n    .from('profiles')\n    .select('id, username, email, display_name, role, created_at, last_login, deleted_at, mfa_enabled', { count: 'exact' })\n\n  // Search\n  if (search) {\n    query = query.or(`username.ilike.%${search}%,email.ilike.%${search}%,display_name.ilike.%${search}%`)\n  }\n\n  // Filter by role\n  if (role) {\n    query = query.eq('role', role)\n  }\n\n  // Filter by status\n  if (status === 'active') {\n    query = query.is('deleted_at', null)\n  } else if (status === 'deleted') {\n    query = query.not('deleted_at', 'is', null)\n  }\n\n  // Sort\n  query = query.order(sort, { ascending: order === 'asc' })\n\n  // Paginate\n  query = query.range(offset, offset + limit - 1)\n\n  const { data: users, error, count } = await query\n\n  if (error) {\n    return <div>Error loading users: {error.message}</div>\n  }\n\n  const totalPages = Math.ceil((count || 0) / limit)\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <h1 className=\"text-3xl font-bold\">User Management</h1>\n      </div>\n\n      <div className=\"flex gap-4\">\n        <UserSearch defaultValue={search} />\n        <UserFilters\n          defaultRole={role}\n          defaultStatus={status}\n          defaultSort={sort}\n          defaultOrder={order}\n        />\n      </div>\n\n      <UserTable users={users || []} />\n\n      <div className=\"flex items-center justify-between\">\n        <p className=\"text-sm text-muted-foreground\">\n          Showing {offset + 1}-{Math.min(offset + limit, count || 0)} of {count || 0} users\n        </p>\n        <div className=\"flex gap-2\">\n          <Button\n            variant=\"outline\"\n            disabled={page <= 1}\n            asChild\n          >\n            <Link href={`/admin/users?page=${page - 1}&search=${search}&role=${role || ''}&status=${status}&sort=${sort}&order=${order}`}>\n              Previous\n            </Link>\n          </Button>\n          <Button\n            variant=\"outline\"\n            disabled={page >= totalPages}\n            asChild\n          >\n            <Link href={`/admin/users?page=${page + 1}&search=${search}&role=${role || ''}&status=${status}&sort=${sort}&order=${order}`}>\n              Next\n            </Link>\n          </Button>\n        </div>\n      </div>\n    </div>\n  )\n}"
          }
        ]
      },
      {
        "id": "TASK-012",
        "title": "Create User Detail/Edit Page",
        "priority": "critical",
        "dependencies": ["TASK-011"],
        "estimated_hours": 3.5,
        "type": "frontend",
        "description": "Create user detail page with edit form, password reset, role change, and delete actions. Uses Server Component for data, Client Components for forms.",
        "acceptance_criteria": [
          "File created: app/admin/users/[userId]/page.tsx",
          "Display user profile: username, email, display_name, role, created_at, last_login, MFA status",
          "Edit form: UserEditForm (Client Component, React Hook Form + Zod)",
          "Password reset button → modal with temporary/custom options",
          "Change role button (super_admin only) → modal with role dropdown",
          "Soft delete button → confirmation modal",
          "All forms use Server Actions (updateUser, resetPassword, etc.)",
          "Success/error toast notifications",
          "Redirect to user list on delete",
          "Loading states during mutations"
        ],
        "files": {
          "create": [
            "app/admin/users/[userId]/page.tsx",
            "components/admin/UserEditForm.tsx",
            "components/admin/PasswordResetDialog.tsx",
            "components/admin/ChangeRoleDialog.tsx",
            "components/admin/DeleteUserDialog.tsx"
          ],
          "modify": []
        },
        "implementation_notes": [
          "Follow SignupForm pattern: Client Component with useState, handleSubmit",
          "Use React Hook Form + zodResolver for validation",
          "Password reset: Show temp password in modal (copy to clipboard)",
          "Role change: Only show button if current user is super_admin",
          "Delete: Confirmation modal with 'Are you sure?' message",
          "Use shadcn/ui Dialog for modals",
          "Call revalidatePath in Server Actions to update UI",
          "Show success toast: 'User updated successfully'"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "// components/admin/UserEditForm.tsx\n'use client'\n\nimport { useForm } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { updateUserSchema, type UpdateUserInput } from '@/lib/admin/validators'\nimport { updateUser } from '@/app/admin/actions'\nimport { Button } from '@/components/ui/button'\nimport { Input } from '@/components/ui/input'\nimport { Label } from '@/components/ui/label'\nimport { useState } from 'react'\n\ninterface UserEditFormProps {\n  userId: string\n  user: {\n    username: string\n    email: string\n    display_name: string | null\n  }\n}\n\nexport function UserEditForm({ userId, user }: UserEditFormProps) {\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [success, setSuccess] = useState(false)\n\n  const form = useForm<UpdateUserInput>({\n    resolver: zodResolver(updateUserSchema),\n    defaultValues: {\n      username: user.username,\n      email: user.email,\n      display_name: user.display_name || '',\n    },\n  })\n\n  const onSubmit = async (data: UpdateUserInput) => {\n    setLoading(true)\n    setError(null)\n    setSuccess(false)\n\n    const result = await updateUser(userId, data)\n\n    if (result.success) {\n      setSuccess(true)\n      setTimeout(() => setSuccess(false), 3000)\n    } else {\n      setError(result.error)\n    }\n\n    setLoading(false)\n  }\n\n  return (\n    <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n      <div>\n        <Label htmlFor=\"username\">Username</Label>\n        <Input\n          id=\"username\"\n          {...form.register('username')}\n          disabled={loading}\n        />\n        {form.formState.errors.username && (\n          <p className=\"text-sm text-red-500\">\n            {form.formState.errors.username.message}\n          </p>\n        )}\n      </div>\n\n      <div>\n        <Label htmlFor=\"email\">Email</Label>\n        <Input\n          id=\"email\"\n          type=\"email\"\n          {...form.register('email')}\n          disabled={loading}\n        />\n        {form.formState.errors.email && (\n          <p className=\"text-sm text-red-500\">\n            {form.formState.errors.email.message}\n          </p>\n        )}\n      </div>\n\n      <div>\n        <Label htmlFor=\"display_name\">Display Name</Label>\n        <Input\n          id=\"display_name\"\n          {...form.register('display_name')}\n          disabled={loading}\n        />\n        {form.formState.errors.display_name && (\n          <p className=\"text-sm text-red-500\">\n            {form.formState.errors.display_name.message}\n          </p>\n        )}\n      </div>\n\n      {error && (\n        <div className=\"rounded bg-red-50 p-3 text-sm text-red-800\">\n          {error}\n        </div>\n      )}\n\n      {success && (\n        <div className=\"rounded bg-green-50 p-3 text-sm text-green-800\">\n          User updated successfully!\n        </div>\n      )}\n\n      <Button type=\"submit\" disabled={loading}>\n        {loading ? 'Saving...' : 'Save Changes'}\n      </Button>\n    </form>\n  )\n}"
          }
        ]
      },
      {
        "id": "TASK-013",
        "title": "Create Audit Log Viewer Page",
        "priority": "high",
        "dependencies": ["TASK-010"],
        "estimated_hours": 3,
        "type": "frontend",
        "description": "Create audit log viewer with filters (action, admin, target user, date range) and CSV export. Server Component for data, Client Components for filters and export.",
        "acceptance_criteria": [
          "File created: app/admin/audit-logs/page.tsx",
          "Display paginated audit logs (100 per page)",
          "Filter by action type (dropdown)",
          "Filter by admin (select from admin list)",
          "Filter by target user (search input)",
          "Filter by date range (from/to date pickers)",
          "Sort by timestamp DESC (default)",
          "CSV export button → downloads filtered results",
          "Display: timestamp, admin username, action, target username, old/new values",
          "Uses shadcn/ui Table component",
          "Server Component for data fetching"
        ],
        "files": {
          "create": [
            "app/admin/audit-logs/page.tsx",
            "app/admin/audit-logs/export/route.ts",
            "components/admin/AuditLogTable.tsx",
            "components/admin/AuditLogFilters.tsx",
            "components/admin/ExportButton.tsx"
          ],
          "modify": []
        },
        "implementation_notes": [
          "Follow UserList pattern: Server Component + Client filters",
          "Join audit_logs with profiles to get admin/target usernames",
          "CSV export: API Route at /admin/audit-logs/export",
          "Use csv-stringify library for CSV generation",
          "Date range: Use date-fns for formatting",
          "Export button: Client Component that calls API route",
          "Display JSONB old/new values as formatted JSON (collapsible)",
          "Add loading skeleton while fetching"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "// app/admin/audit-logs/export/route.ts\nimport { createClient } from '@/lib/supabase/server'\nimport { stringify } from 'csv-stringify/sync'\nimport { NextRequest, NextResponse } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  const supabase = await createClient()\n\n  // Check authorization\n  const { data: { session } } = await supabase.auth.getSession()\n  if (!session) {\n    return new NextResponse('Unauthorized', { status: 401 })\n  }\n\n  const { data: admin } = await supabase\n    .from('profiles')\n    .select('role')\n    .eq('id', session.user.id)\n    .single()\n\n  if (!admin || !['admin', 'super_admin'].includes(admin.role)) {\n    return new NextResponse('Forbidden', { status: 403 })\n  }\n\n  // Get filters from URL params\n  const { searchParams } = new URL(request.url)\n  const action = searchParams.get('action')\n  const adminId = searchParams.get('admin')\n  const targetId = searchParams.get('target')\n  const from = searchParams.get('from')\n  const to = searchParams.get('to')\n\n  // Build query\n  let query = supabase\n    .from('audit_logs')\n    .select(`\n      id,\n      timestamp,\n      action,\n      old_value,\n      new_value,\n      ip_address,\n      admin:profiles!audit_logs_admin_id_fkey(username),\n      target_user:profiles!audit_logs_target_user_id_fkey(username)\n    `)\n\n  if (action) query = query.eq('action', action)\n  if (adminId) query = query.eq('admin_id', adminId)\n  if (targetId) query = query.eq('target_user_id', targetId)\n  if (from) query = query.gte('timestamp', from)\n  if (to) query = query.lte('timestamp', to)\n\n  query = query.order('timestamp', { ascending: false })\n\n  const { data: logs, error } = await query\n\n  if (error) {\n    return new NextResponse('Error fetching logs', { status: 500 })\n  }\n\n  // Convert to CSV\n  const csv = stringify(logs || [], {\n    header: true,\n    columns: ['timestamp', 'admin.username', 'action', 'target_user.username', 'old_value', 'new_value', 'ip_address'],\n  })\n\n  return new NextResponse(csv, {\n    headers: {\n      'Content-Type': 'text/csv',\n      'Content-Disposition': `attachment; filename=\"audit-logs-${new Date().toISOString()}.csv\"`,\n    },\n  })\n}"
          }
        ]
      },
      {
        "id": "TASK-014",
        "title": "Create MFA Setup Flow (Basic)",
        "priority": "medium",
        "dependencies": ["TASK-010"],
        "estimated_hours": 3,
        "type": "frontend",
        "description": "Create MFA setup page for admins who haven't enabled MFA. Uses Supabase MFA API with TOTP (authenticator app). Generate recovery codes.",
        "acceptance_criteria": [
          "File created: app/admin/mfa-setup/page.tsx",
          "Display QR code for authenticator app (Supabase MFA enroll)",
          "Input field for TOTP code verification",
          "Generate 10 recovery codes (bcrypt hashed, stored in mfa_recovery_codes)",
          "Display recovery codes once (copy to clipboard)",
          "Mark mfa_enabled = true on success",
          "Redirect to /admin dashboard after setup",
          "Error handling: invalid TOTP code, enrollment failed",
          "Grace period warning: 'X days remaining to enable MFA'"
        ],
        "files": {
          "create": ["app/admin/mfa-setup/page.tsx", "components/admin/MFASetupForm.tsx"],
          "modify": []
        },
        "implementation_notes": [
          "Use Supabase MFA: supabase.auth.mfa.enroll({ factorType: 'totp' })",
          "Display QR code: Convert totp_uri to QR code (use qrcode library)",
          "Verify TOTP: supabase.auth.mfa.verify({ factorId, code })",
          "Generate recovery codes: 10 random 8-character codes",
          "Hash recovery codes with bcrypt before storing",
          "Show recovery codes in modal (copy to clipboard, download as txt)",
          "Only allow setup once (check mfa_enabled before showing form)",
          "Grace period calculation: mfa_enforced_at + 7 days"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "// components/admin/MFASetupForm.tsx\n'use client'\n\nimport { useState } from 'react'\nimport { createClient } from '@/lib/supabase/client'\nimport { Button } from '@/components/ui/button'\nimport { Input } from '@/components/ui/input'\nimport QRCode from 'qrcode'\n\nexport function MFASetupForm() {\n  const [step, setStep] = useState<'enroll' | 'verify' | 'recovery'>('enroll')\n  const [qrCode, setQrCode] = useState<string | null>(null)\n  const [factorId, setFactorId] = useState<string | null>(null)\n  const [totpCode, setTotpCode] = useState('')\n  const [recoveryCodes, setRecoveryCodes] = useState<string[]>([])\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const supabase = createClient()\n\n  const handleEnroll = async () => {\n    setLoading(true)\n    setError(null)\n\n    try {\n      const { data, error } = await supabase.auth.mfa.enroll({\n        factorType: 'totp',\n      })\n\n      if (error) throw error\n\n      // Generate QR code\n      const qrCodeUrl = await QRCode.toDataURL(data.totp.uri)\n      setQrCode(qrCodeUrl)\n      setFactorId(data.id)\n      setStep('verify')\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Enrollment failed')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  const handleVerify = async () => {\n    if (!factorId || !totpCode) return\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      const { error } = await supabase.auth.mfa.verify({\n        factorId,\n        code: totpCode,\n      })\n\n      if (error) throw error\n\n      // Generate recovery codes\n      const codes = Array.from({ length: 10 }, () =>\n        Math.random().toString(36).substring(2, 10).toUpperCase()\n      )\n      setRecoveryCodes(codes)\n\n      // Store hashed recovery codes (via Server Action)\n      // TODO: Create Server Action to hash and store codes\n\n      // Update mfa_enabled in profile\n      await supabase\n        .from('profiles')\n        .update({ mfa_enabled: true })\n        .eq('id', (await supabase.auth.getUser()).data.user!.id)\n\n      setStep('recovery')\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Verification failed')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  if (step === 'enroll') {\n    return (\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">Enable Two-Factor Authentication</h2>\n        <p className=\"text-muted-foreground\">\n          Scan the QR code below with your authenticator app (Google Authenticator, Authy, etc.)\n        </p>\n        <Button onClick={handleEnroll} disabled={loading}>\n          {loading ? 'Setting up...' : 'Start Setup'}\n        </Button>\n        {error && <p className=\"text-red-500\">{error}</p>}\n      </div>\n    )\n  }\n\n  if (step === 'verify') {\n    return (\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">Scan QR Code</h2>\n        {qrCode && <img src={qrCode} alt=\"MFA QR Code\" className=\"mx-auto\" />}\n        <p className=\"text-muted-foreground\">\n          Enter the 6-digit code from your authenticator app\n        </p>\n        <Input\n          type=\"text\"\n          placeholder=\"000000\"\n          value={totpCode}\n          onChange={(e) => setTotpCode(e.target.value)}\n          maxLength={6}\n        />\n        <Button onClick={handleVerify} disabled={loading || totpCode.length !== 6}>\n          {loading ? 'Verifying...' : 'Verify Code'}\n        </Button>\n        {error && <p className=\"text-red-500\">{error}</p>}\n      </div>\n    )\n  }\n\n  if (step === 'recovery') {\n    return (\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">Recovery Codes</h2>\n        <p className=\"text-muted-foreground\">\n          Save these recovery codes in a safe place. Each code can be used once.\n        </p>\n        <div className=\"grid grid-cols-2 gap-2 rounded bg-muted p-4 font-mono text-sm\">\n          {recoveryCodes.map((code, i) => (\n            <div key={i}>{code}</div>\n          ))}\n        </div>\n        <Button onClick={() => navigator.clipboard.writeText(recoveryCodes.join('\\n'))}>\n          Copy Codes\n        </Button>\n        <Button variant=\"outline\" asChild>\n          <a href=\"/admin\">Continue to Dashboard</a>\n        </Button>\n      </div>\n    )\n  }\n\n  return null\n}"
          }
        ]
      },
      {
        "id": "TASK-015",
        "title": "Write E2E Tests for User Management",
        "priority": "high",
        "dependencies": ["TASK-012"],
        "estimated_hours": 4,
        "type": "testing",
        "description": "Write Playwright E2E tests for complete admin workflows: login, user list, user edit, role change, password reset, soft delete. Test authorization failures.",
        "acceptance_criteria": [
          "File created: tests/e2e/admin/user-management.spec.ts",
          "Test: Admin login with valid credentials → redirects to /admin",
          "Test: User list loads → search works → filter works → pagination works",
          "Test: Click user → user detail page loads → edit form works",
          "Test: Update username → success message → audit log created",
          "Test: Reset password → temp password shown → user receives email",
          "Test: Change role (super_admin) → role updated → audit log created",
          "Test: Soft delete user → user marked deleted → cannot login",
          "Test: Non-admin tries to access /admin → 403 Forbidden",
          "Test: Admin tries to edit own profile → error message",
          "All tests pass consistently"
        ],
        "files": {
          "create": ["tests/e2e/admin/user-management.spec.ts", "tests/fixtures/admin-user.ts"],
          "modify": ["playwright.config.ts"]
        },
        "implementation_notes": [
          "Use Playwright test fixtures for admin user",
          "Seed database with test users (via Supabase SQL)",
          "Test isolation: Each test creates/deletes own test data",
          "Use page.goto(), page.click(), page.fill() for interactions",
          "Assert on URL changes: expect(page.url()).toContain('/admin/users')",
          "Assert on DOM elements: expect(page.locator('h1')).toHaveText('User Management')",
          "Test error cases: non-admin access, invalid input, etc.",
          "Clean up: Delete test users after tests complete"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "// tests/e2e/admin/user-management.spec.ts\nimport { test, expect } from '@playwright/test'\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_ROLE_KEY!\n)\n\ntest.describe('Admin User Management', () => {\n  let adminUser: any\n  let testUser: any\n\n  test.beforeAll(async () => {\n    // Create test admin user\n    const { data: admin } = await supabase.auth.admin.createUser({\n      email: 'admin@test.com',\n      password: 'Admin123!',\n      email_confirm: true,\n    })\n\n    await supabase.from('profiles').update({ role: 'admin' }).eq('id', admin.user!.id)\n    adminUser = admin.user\n\n    // Create test regular user\n    const { data: user } = await supabase.auth.admin.createUser({\n      email: 'user@test.com',\n      password: 'User123!',\n      email_confirm: true,\n    })\n\n    testUser = user.user\n  })\n\n  test.afterAll(async () => {\n    // Clean up test users\n    await supabase.auth.admin.deleteUser(adminUser.id)\n    await supabase.auth.admin.deleteUser(testUser.id)\n  })\n\n  test('Admin can log in and access dashboard', async ({ page }) => {\n    // Go to login page\n    await page.goto('http://localhost:3000/login')\n\n    // Fill in credentials\n    await page.fill('input[name=\"email\"]', 'admin@test.com')\n    await page.fill('input[name=\"password\"]', 'Admin123!')\n    await page.click('button[type=\"submit\"]')\n\n    // Should redirect to /admin\n    await expect(page).toHaveURL('http://localhost:3000/admin')\n    await expect(page.locator('h1')).toContainText('Admin Panel')\n  })\n\n  test('Admin can view user list', async ({ page }) => {\n    // Login first\n    await page.goto('http://localhost:3000/login')\n    await page.fill('input[name=\"email\"]', 'admin@test.com')\n    await page.fill('input[name=\"password\"]', 'Admin123!')\n    await page.click('button[type=\"submit\"]')\n\n    // Navigate to users\n    await page.goto('http://localhost:3000/admin/users')\n\n    // Check table loaded\n    await expect(page.locator('table')).toBeVisible()\n    await expect(page.locator('tbody tr')).toHaveCount(greaterThan(0))\n  })\n\n  test('Admin can edit user profile', async ({ page }) => {\n    // Login and navigate to test user\n    await page.goto('http://localhost:3000/login')\n    await page.fill('input[name=\"email\"]', 'admin@test.com')\n    await page.fill('input[name=\"password\"]', 'Admin123!')\n    await page.click('button[type=\"submit\"]')\n\n    await page.goto(`http://localhost:3000/admin/users/${testUser.id}`)\n\n    // Edit username\n    await page.fill('input[name=\"username\"]', 'updated_user')\n    await page.click('button[type=\"submit\"]')\n\n    // Check success message\n    await expect(page.locator('text=User updated successfully')).toBeVisible()\n\n    // Verify audit log created\n    const { data: log } = await supabase\n      .from('audit_logs')\n      .select('*')\n      .eq('target_user_id', testUser.id)\n      .eq('action', 'user_updated')\n      .single()\n\n    expect(log).toBeTruthy()\n  })\n\n  test('Non-admin cannot access admin panel', async ({ page }) => {\n    // Login as regular user\n    await page.goto('http://localhost:3000/login')\n    await page.fill('input[name=\"email\"]', 'user@test.com')\n    await page.fill('input[name=\"password\"]', 'User123!')\n    await page.click('button[type=\"submit\"]')\n\n    // Try to access admin panel\n    await page.goto('http://localhost:3000/admin')\n\n    // Should see 403 or redirect to home\n    const text = await page.textContent('body')\n    expect(text).toMatch(/Forbidden|403/)\n  })\n})"
          }
        ]
      },
      {
        "id": "TASK-016",
        "title": "Write Integration Tests for RLS Policies",
        "priority": "medium",
        "dependencies": ["TASK-006"],
        "estimated_hours": 2.5,
        "type": "testing",
        "description": "Write integration tests to verify RLS policies work correctly: admins can view/edit users, users cannot access admin features, audit logs are immutable.",
        "acceptance_criteria": [
          "File created: tests/integration/rls-policies.test.ts",
          "Test: Admin can SELECT all users",
          "Test: Admin can UPDATE other users (not self)",
          "Test: Admin cannot UPDATE own profile via admin query",
          "Test: User cannot SELECT other users",
          "Test: User cannot UPDATE other users",
          "Test: Admin can SELECT audit logs",
          "Test: Admin cannot UPDATE audit logs",
          "Test: Admin cannot DELETE audit logs",
          "Test: Super admin can change roles",
          "Test: Admin cannot change roles",
          "All tests pass"
        ],
        "files": {
          "create": ["tests/integration/rls-policies.test.ts"],
          "modify": []
        },
        "implementation_notes": [
          "Use Vitest for integration tests",
          "Create test users with different roles (user, admin, super_admin)",
          "Use Supabase client with different auth contexts",
          "Test RLS policy enforcement at database level",
          "Assert on error messages: 'new row violates row-level security policy'",
          "Clean up test data after each test",
          "Run tests against local Supabase instance"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "// tests/integration/rls-policies.test.ts\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest'\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_ROLE_KEY!\n)\n\ndescribe('RLS Policies', () => {\n  let adminUser: any\n  let regularUser: any\n  let targetUser: any\n\n  beforeAll(async () => {\n    // Create test users\n    const { data: admin } = await supabase.auth.admin.createUser({\n      email: 'admin@rls.test',\n      password: 'Test123!',\n    })\n    await supabase.from('profiles').update({ role: 'admin' }).eq('id', admin.user!.id)\n    adminUser = admin.user\n\n    const { data: user } = await supabase.auth.admin.createUser({\n      email: 'user@rls.test',\n      password: 'Test123!',\n    })\n    regularUser = user.user\n\n    const { data: target } = await supabase.auth.admin.createUser({\n      email: 'target@rls.test',\n      password: 'Test123!',\n    })\n    targetUser = target.user\n  })\n\n  afterAll(async () => {\n    await supabase.auth.admin.deleteUser(adminUser.id)\n    await supabase.auth.admin.deleteUser(regularUser.id)\n    await supabase.auth.admin.deleteUser(targetUser.id)\n  })\n\n  it('Admin can view all users', async () => {\n    // Create client with admin session\n    const adminClient = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        auth: {\n          persistSession: false,\n        },\n      }\n    )\n\n    // Sign in as admin\n    await adminClient.auth.signInWithPassword({\n      email: 'admin@rls.test',\n      password: 'Test123!',\n    })\n\n    // Query all users\n    const { data, error } = await adminClient.from('profiles').select('*')\n\n    expect(error).toBeNull()\n    expect(data).toBeTruthy()\n    expect(data!.length).toBeGreaterThan(0)\n  })\n\n  it('Regular user cannot view all users', async () => {\n    const userClient = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        auth: {\n          persistSession: false,\n        },\n      }\n    )\n\n    await userClient.auth.signInWithPassword({\n      email: 'user@rls.test',\n      password: 'Test123!',\n    })\n\n    const { data, error } = await userClient.from('profiles').select('*')\n\n    // Should only see own profile or none\n    expect(data?.length).toBeLessThanOrEqual(1)\n  })\n\n  it('Admin cannot update own profile via admin query', async () => {\n    const adminClient = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n    )\n\n    await adminClient.auth.signInWithPassword({\n      email: 'admin@rls.test',\n      password: 'Test123!',\n    })\n\n    // Try to update own username\n    const { error } = await adminClient\n      .from('profiles')\n      .update({ username: 'hacked_admin' })\n      .eq('id', adminUser.id)\n\n    // Should fail due to RLS policy\n    expect(error).toBeTruthy()\n    expect(error?.message).toMatch(/row-level security policy/)\n  })\n\n  it('Audit logs are immutable', async () => {\n    const adminClient = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n    )\n\n    await adminClient.auth.signInWithPassword({\n      email: 'admin@rls.test',\n      password: 'Test123!',\n    })\n\n    // Create audit log\n    const { data: log } = await adminClient.from('audit_logs').insert({\n      admin_id: adminUser.id,\n      action: 'test_action',\n      target_user_id: targetUser.id,\n    }).select().single()\n\n    // Try to update audit log\n    const { error: updateError } = await adminClient\n      .from('audit_logs')\n      .update({ action: 'modified_action' })\n      .eq('id', log!.id)\n\n    expect(updateError).toBeTruthy()\n\n    // Try to delete audit log\n    const { error: deleteError } = await adminClient\n      .from('audit_logs')\n      .delete()\n      .eq('id', log!.id)\n\n    expect(deleteError).toBeTruthy()\n  })\n})"
          }
        ]
      },
      {
        "id": "TASK-017",
        "title": "Write Unit Tests for Validators and Utilities",
        "priority": "low",
        "dependencies": ["TASK-008"],
        "estimated_hours": 1.5,
        "type": "testing",
        "description": "Write unit tests for Zod schemas, password generation, CSV conversion, and date formatting utilities.",
        "acceptance_criteria": [
          "File created: tests/unit/validators.test.ts",
          "Test: updateUserSchema validates username (3-20 chars, alphanumeric)",
          "Test: updateUserSchema rejects invalid email",
          "Test: resetPasswordSchema requires password for custom type",
          "Test: changeRoleSchema only accepts 'user' or 'admin'",
          "Test: permanentDeleteSchema requires 'DELETE' literal",
          "File created: tests/unit/password.test.ts",
          "Test: generateTemporaryPassword meets complexity requirements",
          "All tests pass"
        ],
        "files": {
          "create": ["tests/unit/validators.test.ts", "tests/unit/password.test.ts"],
          "modify": []
        },
        "implementation_notes": [
          "Use Vitest for unit tests",
          "Test Zod schemas with valid and invalid inputs",
          "Assert on error messages: expect(result.error.issues[0].message).toBe('...')",
          "Test password generator: Check length, uppercase, lowercase, number, special char",
          "Mock external dependencies (Supabase client, etc.)",
          "Fast tests (< 100ms each)"
        ],
        "code_snippets": [
          {
            "language": "typescript",
            "code": "// tests/unit/validators.test.ts\nimport { describe, it, expect } from 'vitest'\nimport { updateUserSchema, resetPasswordSchema, changeRoleSchema, permanentDeleteSchema } from '@/lib/admin/validators'\n\ndescribe('updateUserSchema', () => {\n  it('accepts valid username', () => {\n    const result = updateUserSchema.safeParse({\n      username: 'valid_user123',\n      email: 'test@example.com',\n    })\n\n    expect(result.success).toBe(true)\n  })\n\n  it('rejects short username', () => {\n    const result = updateUserSchema.safeParse({\n      username: 'ab',\n      email: 'test@example.com',\n    })\n\n    expect(result.success).toBe(false)\n    if (!result.success) {\n      expect(result.error.issues[0].message).toContain('at least 3 characters')\n    }\n  })\n\n  it('rejects username with special characters', () => {\n    const result = updateUserSchema.safeParse({\n      username: 'user@name',\n      email: 'test@example.com',\n    })\n\n    expect(result.success).toBe(false)\n    if (!result.success) {\n      expect(result.error.issues[0].message).toContain('alphanumeric')\n    }\n  })\n\n  it('rejects invalid email', () => {\n    const result = updateUserSchema.safeParse({\n      username: 'valid_user',\n      email: 'not-an-email',\n    })\n\n    expect(result.success).toBe(false)\n    if (!result.success) {\n      expect(result.error.issues[0].message).toContain('Invalid email')\n    }\n  })\n})\n\ndescribe('resetPasswordSchema', () => {\n  it('accepts temporary type without password', () => {\n    const result = resetPasswordSchema.safeParse({\n      type: 'temporary',\n    })\n\n    expect(result.success).toBe(true)\n  })\n\n  it('requires password for custom type', () => {\n    const result = resetPasswordSchema.safeParse({\n      type: 'custom',\n    })\n\n    expect(result.success).toBe(false)\n    if (!result.success) {\n      expect(result.error.issues[0].message).toContain('Password is required')\n    }\n  })\n\n  it('validates password complexity', () => {\n    const result = resetPasswordSchema.safeParse({\n      type: 'custom',\n      password: 'weakpass',\n    })\n\n    expect(result.success).toBe(false)\n    if (!result.success) {\n      expect(result.error.issues[0].message).toContain('at least 8 characters')\n    }\n  })\n})\n\ndescribe('permanentDeleteSchema', () => {\n  it('accepts DELETE literal', () => {\n    const result = permanentDeleteSchema.safeParse({\n      confirm: 'DELETE',\n    })\n\n    expect(result.success).toBe(true)\n  })\n\n  it('rejects anything other than DELETE', () => {\n    const result = permanentDeleteSchema.safeParse({\n      confirm: 'delete',\n    })\n\n    expect(result.success).toBe(false)\n    if (!result.success) {\n      expect(result.error.issues[0].message).toContain('type DELETE')\n    }\n  })\n})"
          }
        ]
      },
      {
        "id": "TASK-018",
        "title": "Documentation and Deployment Prep",
        "priority": "medium",
        "dependencies": ["TASK-015", "TASK-016", "TASK-017"],
        "estimated_hours": 2,
        "type": "infrastructure",
        "description": "Create admin system documentation (README, API docs, deployment guide). Prepare environment variables for production. Create first super_admin user migration.",
        "acceptance_criteria": [
          "File created: docs/admin-system-guide.md (how to use admin panel)",
          "File created: docs/admin-api-reference.md (Server Actions, endpoints)",
          "File created: docs/admin-deployment.md (environment setup, migrations)",
          "Migration created: 20251028_create_first_super_admin.sql",
          "Environment variables documented: NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY",
          "Deployment checklist created: Run migrations, create super_admin, enable MFA",
          "All documentation reviewed and complete"
        ],
        "files": {
          "create": [
            "docs/admin-system-guide.md",
            "docs/admin-api-reference.md",
            "docs/admin-deployment.md",
            "supabase/migrations/20251028_create_first_super_admin.sql"
          ],
          "modify": ["README.md"]
        },
        "implementation_notes": [
          "Documentation should be clear and concise",
          "Include screenshots (once UI is complete)",
          "API reference: Document all Server Actions (params, return types, errors)",
          "Deployment guide: Step-by-step instructions for first deployment",
          "Super admin migration: UPDATE first user to super_admin role",
          "Environment variables: Document required secrets",
          "Add admin system section to main README.md"
        ],
        "code_snippets": [
          {
            "language": "sql",
            "code": "-- supabase/migrations/20251028_create_first_super_admin.sql\n-- This migration promotes the first user to super_admin\n-- Replace the email with your actual admin email\n\nUPDATE profiles\nSET role = 'super_admin'\nWHERE email = 'your-admin-email@example.com';\n\n-- Verify super_admin was created\nDO $$\nBEGIN\n  IF NOT EXISTS (SELECT 1 FROM profiles WHERE role = 'super_admin') THEN\n    RAISE EXCEPTION 'No super_admin found. Update the email in the migration.';\n  END IF;\nEND $$;"
          }
        ]
      }
    ],
    "dependency_graph": {
      "TASK-001": [],
      "TASK-002": ["TASK-001"],
      "TASK-003": ["TASK-002"],
      "TASK-004": ["TASK-002"],
      "TASK-005": ["TASK-003", "TASK-004"],
      "TASK-006": ["TASK-005"],
      "TASK-007": ["TASK-006"],
      "TASK-008": ["TASK-001"],
      "TASK-009": ["TASK-007", "TASK-008"],
      "TASK-010": ["TASK-007"],
      "TASK-011": ["TASK-009", "TASK-010"],
      "TASK-012": ["TASK-011"],
      "TASK-013": ["TASK-010"],
      "TASK-014": ["TASK-010"],
      "TASK-015": ["TASK-012"],
      "TASK-016": ["TASK-006"],
      "TASK-017": ["TASK-008"],
      "TASK-018": ["TASK-015", "TASK-016", "TASK-017"]
    },
    "risk_assessment": [
      {
        "task_id": "TASK-003",
        "risk": "Audit log triggers might not capture IP address correctly in Supabase environment",
        "severity": "medium",
        "mitigation": "Test triggers thoroughly. Use Supabase request context if available, fallback to null if not",
        "rollback": "Drop triggers, create audit logs manually in Server Actions instead"
      },
      {
        "task_id": "TASK-005",
        "risk": "RLS policies might conflict with existing policies or prevent legitimate operations",
        "severity": "high",
        "mitigation": "Test policies in isolation before deploying. Use service role key for testing. Review all existing policies first",
        "rollback": "Drop new policies, revert to previous state via migration down script"
      },
      {
        "task_id": "TASK-007",
        "risk": "Middleware might block legitimate admin access due to bugs or race conditions",
        "severity": "high",
        "mitigation": "Add extensive logging. Test with multiple admin users. Add bypass mechanism for super_admin in emergency",
        "rollback": "Remove middleware matcher, revert to route-level auth checks"
      },
      {
        "task_id": "TASK-009",
        "risk": "Server Actions might fail silently or return incorrect error messages",
        "severity": "medium",
        "mitigation": "Add comprehensive error handling. Log all errors to console. Return typed error responses",
        "rollback": "Convert Server Actions to API Routes (more traditional error handling)"
      },
      {
        "task_id": "TASK-011",
        "risk": "User list might be slow with 10,000+ users due to full-text search",
        "severity": "medium",
        "mitigation": "Add GIN index for full-text search. Use pagination with LIMIT 50. Test with large dataset (seed 10,000 users)",
        "rollback": "Remove full-text search, use simple ILIKE (slower but simpler)"
      },
      {
        "task_id": "TASK-014",
        "risk": "MFA setup might fail due to Supabase MFA API limitations or bugs",
        "severity": "high",
        "mitigation": "Test MFA flow thoroughly with multiple authenticator apps. Add fallback to email-based 2FA",
        "rollback": "Make MFA optional (not enforced) until issues resolved"
      },
      {
        "task_id": "TASK-015",
        "risk": "E2E tests might be flaky due to timing issues or database state",
        "severity": "low",
        "mitigation": "Use Playwright waitForSelector(), waitForNavigation(). Seed database before each test. Clean up after tests",
        "rollback": "Skip E2E tests, rely on manual testing for MVP"
      }
    ],
    "testing_strategy": {
      "unit_tests": [
        "tests/unit/validators.test.ts - Test Zod schemas",
        "tests/unit/password.test.ts - Test password generation",
        "tests/unit/formatters.test.ts - Test date formatting",
        "tests/unit/csv.test.ts - Test CSV conversion"
      ],
      "integration_tests": [
        "tests/integration/rls-policies.test.ts - Test RLS policy enforcement",
        "tests/integration/audit-triggers.test.ts - Test database triggers",
        "tests/integration/server-actions.test.ts - Test Server Actions in isolation"
      ],
      "e2e_tests": [
        "tests/e2e/admin/user-management.spec.ts - Test complete user CRUD workflow",
        "tests/e2e/admin/role-management.spec.ts - Test role changes",
        "tests/e2e/admin/audit-logs.spec.ts - Test audit log viewer and export",
        "tests/e2e/admin/mfa-setup.spec.ts - Test MFA enrollment flow"
      ],
      "security_tests": [
        "tests/security/unauthorized-access.spec.ts - Test non-admin cannot access /admin",
        "tests/security/privilege-escalation.spec.ts - Test admin cannot escalate to super_admin",
        "tests/security/csrf-protection.spec.ts - Test Server Actions have CSRF protection",
        "tests/security/sql-injection.spec.ts - Test input sanitization"
      ],
      "performance_tests": [
        "Test user list with 10,000 users < 500ms",
        "Test search with 10,000 users < 200ms",
        "Test audit log query with 100,000 logs < 1s"
      ]
    },
    "success_criteria": [
      "All 8 user stories implemented (US-001 through US-008)",
      "All critical tests passing (unit + integration + E2E)",
      "Security audit complete (no unauthorized access, privilege escalation prevented)",
      "Performance benchmarks met (user list < 500ms, search < 200ms)",
      "Documentation complete (admin guide, API reference, deployment guide)",
      "MFA enforced for all admins (7-day grace period)",
      "Audit logs capture all admin actions (immutable, 2-year retention)",
      "RLS policies prevent unauthorized data access",
      "TypeScript compiles with no errors",
      "Dark mode works correctly (follows existing theme)",
      "Responsive design (desktop-first, mobile sidebar collapse)",
      "No console errors in production build",
      "Deployment ready (migrations applied, environment variables set, first super_admin created)"
    ]
  },
  "artifacts": [
    {
      "name": "implementation-plan.md",
      "path": "specs/plans/admin-system-implementation-plan.md"
    }
  ],
  "next_steps": [
    "Upload this plan to GKChatty knowledge base for Builder Pro BMAD",
    "Begin implementation with TASK-001 (Install Dependencies)",
    "Execute tasks in dependency order (follow dependency_graph)",
    "Run tests after completing each phase (Phase A: infrastructure, Phase B: components, etc.)",
    "Present to user after Phase D (Testing & Polish) complete"
  ]
}
